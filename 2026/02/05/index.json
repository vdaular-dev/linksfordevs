[
  {
    "Title": "Building a C compiler with a team of parallel Claudes",
    "Url": "https://www.anthropic.com/engineering/building-c-compiler",
    "Timestamp": "2026-02-05T23:02:17",
    "Domain": "www.anthropic.com",
    "Description": "Anthropic is an AI safety and research company that's working to build reliable, interpretable, and steerable AI systems."
  },
  {
    "Title": "Orchestrate teams of Claude Code sessions - Claude Code Docs",
    "Url": "https://code.claude.com/docs/en/agent-teams",
    "Timestamp": "2026-02-05T22:02:15",
    "Domain": "code.claude.com",
    "Description": "Coordinate multiple Claude Code instances working together as a team, with shared tasks, inter-agent messaging, and centralized management."
  },
  {
    "Title": "Commission trials European open source communications software | Euractiv",
    "Url": "https://www.euractiv.com/news/commission-trials-european-open-source-communications-software/",
    "Timestamp": "2026-02-05T21:02:19",
    "Domain": "www.euractiv.com",
    "Description": "The Matrix protocol is being lined up as a sovereign backup to Microsoft Teams"
  },
  {
    "Title": "Claude Opus 4.6",
    "Url": "https://www.anthropic.com/news/claude-opus-4-6",
    "Timestamp": "2026-02-05T19:02:26",
    "Domain": "www.anthropic.com",
    "Description": "We’re upgrading our smartest model. Across agentic coding, computer use, tool use, search, and finance, Opus 4.6 is an industry-leading model, often by wide margin. "
  },
  {
    "Title": "Introducing GPT-5.3-Codex",
    "Url": "https://openai.com/index/introducing-gpt-5-3-codex/",
    "Timestamp": "2026-02-05T19:02:21",
    "Domain": "openai.com",
    "Description": "GPT-5.3-Codex is a Codex-native agent that pairs frontier coding performance with general reasoning to support long-horizon, real-world technical work."
  },
  {
    "Title": "I Bought the Display From War Games!  Let's hack it...",
    "Url": "https://youtube.com/watch?v=JrwvIKK3D2o",
    "Timestamp": "2026-02-05T15:02:13",
    "Domain": "youtube.com",
    "Description": "Dave details the HP1345A display used to make the famous scens in the movie War Games."
  },
  {
    "Title": "Owning a $5M data center",
    "Url": "https://blog.comma.ai/datacenter/",
    "Timestamp": "2026-02-05T10:02:07",
    "Domain": "blog.comma.ai",
    "Description": "Data centers are cool, everyone should have one."
  },
  {
    "Title": "Getting the main thing right",
    "Url": "https://www.seangoedecke.com/getting-the-main-thing-right/",
    "Timestamp": "2026-02-05T09:02:06",
    "Domain": "www.seangoedecke.com",
    "Description": "When you’re running a project in a tech company, understanding that your main job is to ship the project goes a surprisingly long way. So many engineers spend their time on peripheral questions (like the choice of technology X or Y) when core questions about shipping the product (for instance, how all the critical paths will actually work) are still unanswered1."
  },
  {
    "Title": "OpenClaw is What Apple Intelligence Should Have Been",
    "Url": "https://www.jakequist.com/thoughts/openclaw-is-what-apple-intelligence-should-have-been",
    "Timestamp": "2026-02-05T07:02:13",
    "Domain": "www.jakequist.com",
    "Description": "Something strange is happening with Mac Minis. They’re selling out everywhere, and it’s not because people suddenly need more coffee table computers.\nIf you browse Reddit or HN, you’ll see the same pattern: people are buying Mac Minis specifically to run AI agents with computer use. They’re setting up headless machines whose sole job is to automate their workflows. OpenClaw—the open-source framework that lets you run Claude, GPT-5, or whatever model you want to actually control your computer—has become the killer app for Mac hardware. Not Final Cut. Not Logic. An AI agent that clicks buttons."
  },
  {
    "Title": "Binary Star",
    "Url": "https://xkcd.com/3203/",
    "Timestamp": "2026-02-05T05:02:32",
    "Domain": "xkcd.com",
    "Description": ""
  },
  {
    "Title": "Command Line Interface Consumer for Kafka in C# | no dogma blog",
    "Url": "https://nodogmablog.bryanhogan.net/2026/02/command-line-interface-consumer-for-kafka-in-c/",
    "Timestamp": "2026-02-05T02:02:11",
    "Domain": "nodogmablog.bryanhogan.net",
    "Description": "I used to use the Confluent CLI to consume messages from Kafka, but recently it stopped working for me. So I wrote my own simple CLI consumer in C#."
  },
  {
    "Title": "Why do we use async-await in our Code",
    "Url": "https://furotmark.github.io/2026/02/04/Why-Do-We-Use-Async-Await-In-Our-Code.html",
    "Timestamp": "2026-02-05T00:03:43",
    "Domain": "furotmark.github.io",
    "Description": "In the project I am currently working on, we inherited a codebase written in an older version of .NET Framework. The ASP.NET part of it was still using synchronous controller methods. This wasn’t changed for a long time because, why bother if it works? Then, some newer methods became async Task type methods with async code. Then we continued to have both, with some wiring when we went from sync to async. Then a performance problem came up. The issue was weird, and we didn’t know whether the wiring was at fault or not. So we just went in and updated all the old methods into async methods without changing the logic or anything. To our surprise, the same code, on the same .NET Framework, on the same machine, started responding 29% better. Then we did some minor fixes, and that percent became even higher to ~44% Iteration From (ms) To (ms) Absolute Improvement (ms) Improvement (%) Sync → Async controllers 276 197 79 28.6% Sync → Async controllers + code optimizations 276 155 121 43.8% These results caught me off guard, so I wanted to find out what was happening behind the scenes, how async-await actually works, and why it led to such a big performance boost. What is asynchronous programming? First, let’s look at a few definitions of asynchronous programming: [!NOTE] JavaScript Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be responsive to other events while that task runs, rather than having to wait until that task has finished. Once that task has finished, your program is presented with the result.[^1](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS/Introducing) [!NOTE] Rust Asynchronous programming is an abstraction that lets us express our code in terms of potential pausing points and eventual results that take care of the details of coordination for us. [^2](https://doc.rust-lang.org/book/ch17-00-async-await.html) [!NOTE] Dotnet Async methods are intended to be non-blocking operations. An await expression in an async method doesn’t block the current thread while the awaited task is running. Instead, the expression signs up the rest of the method as a continuation and returns control to the caller of the async method.[^3](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model#threads) What we want to achieve with async code is not to block other operations from executing while a longer-running task is being processed. This provides a pleasant user experience. Think of a button that plays a song: once pressed, nothing else can happen; you cannot pause it, stop it, change the volume, or manage the playlist until the song finishes. This is what async enables. Similar solutions include using events or callbacks. Events enable operations to be performed at command when the event is triggered. Callbacks are another way to pass an operation to another operation, with the expectation that the second will call the first when needed. Both are used in different scenarios, but without oversight, they can be hard to follow and lead to event spaghetti, callback hell, or other popular code disasters. The async-await combo became popular because of this. It enables writing code that looks like normal synchronous code while adding asynchronous capabilities in a simple way. It’s important to clear up two related concepts that people often mix up: concurrency and parallelism. Knowing the difference helps you get the most out of async programming. Concurrency ≠ Parallelism: understanding the difference Both seem to do multiple things at once, and they do; the difference is in how they do it. To better understand it, we need to realize that these notions apply to the CPU. Meaning that the operating system has other system components that also do work, and when we are talking about concurrency, we mainly are thinking about what the CPU can do while the other components respond. We can group these system components and name them I/O-bound tasks, such as waiting for the disk to read a file’s contents, waiting for a network response, or waiting for results from a database. Even with a single-core CPU, we can better utilize it while we wait for I/O (Input/Output) responses and handle the next task. The example would be having one chef making a pasta dish. First, a pot is put on the stove filled with water. Then some salt is added to the pot, and the heat is turned on. While we wait for the pasta water to boil, we can do the next task, like grate some cheese. When the water reaches a boil, we return and put the pasta in, then do another task while it cooks, and so on. For parallelism, we need multicore processors, which have been a feature since 2005. Meaning that if you run something on a modern PC, it will most likely be on a multicore processor (CPU). Usually, a thread pool manages tasks and the available threads to perform the work. If we were to go on the previous example. This would mean that multiple chefs are making a pasta dish. Chef-1 could take care of the pasta task, and Chef-2 could do the sauce for it. If you observe closely, you can see that in this example, the chefs work in parallel but not concurrently. Each chef handles the entire task, start to finish, by themselves, making each task “synchronous”. Mixing the two concepts, concurrency and parallelism, would mean having Chef-1 put the water to boil while, in parallel, Chef-2 cuts onions for the sauce. If Chef-1 finishes faster, it could continue chopping tomatoes for the sauce. Then, when Chef-2 finishes, it can continue the pasta task or finish it if Chef-1 is still busy. This is what async-await actually does behind the scenes. It helps with doing tasks so that blocked parts can be resumed later. If the context allows another thread to pick up the task, it can happen, but it is not guaranteed. This is why concurrency does not always guarantee parallelism. All other threads can be busy with other things, so the same thread will be used when the I/O operation finishes. In summary, embracing asynchronous programming with async-await in .NET is more than a modern trend. It’s a practical way to achieve real-world performance improvements, often with minimal code changes. By clarifying the concepts of concurrency and parallelism and understanding their impact, we can write applications that are not only faster but also more responsive and maintainable. Revisiting and updating legacy codebases can yield surprising benefits and remind us that sometimes, questioning “what just works” leads to breakthroughs that benefit both developers and users alike."
  },
  {
    "Title": "The missed incident priority: The Near Miss",
    "Url": "https://jensrantil.github.io/posts/near-miss-incidents/",
    "Timestamp": "2026-02-05T00:03:40",
    "Domain": "jensrantil.github.io",
    "Description": "Near misses are"
  },
  {
    "Title": "Claude Didn’t Kill Craftsmanship — Mergify",
    "Url": "https://mergify.com/blog/claude-didnt-kill-craftsmanship",
    "Timestamp": "2026-02-05T00:03:34",
    "Domain": "mergify.com",
    "Description": "AI doesn't remove craftsmanship: it moves it. The goal was never to protect the purity of the saw. It's to build good furniture. Engineers can now focus on intent, judgment, and product quality instead of translating tickets into code."
  },
  {
    "Title": "Claude Code Debugging: Stop Arguing, Start Showing",
    "Url": "https://www.nathanonn.com/claude-code-debugging-visibility-methods/",
    "Timestamp": "2026-02-05T00:03:30",
    "Domain": "www.nathanonn.com",
    "Description": "Struggling with Claude Code debugging? Learn why AI fails at fixing bugs—and two practical methods to give it the visibility it needs to solve problems on the first try."
  },
  {
    "Title": "Karim Shehadeh - Craftsmanship vs. Abstraction",
    "Url": "https://karim.cloud/blog/posts/craftsmanship-vs-abstraction",
    "Timestamp": "2026-02-05T00:03:25",
    "Domain": "karim.cloud",
    "Description": "We remake ourselves over our lifetime, usually as a result driven by personal change. Sometimes it comes from shifts in our own lives, and sometimes from inspiration we feel compelled to pursue. Either way, it tends to be localized to an individual journey. What is happening right now feels different. This is a shift on a national, and possibly global, scale, one that demands change regardless of our personal feelings about it. This is especially true for software developers, in part because the..."
  },
  {
    "Title": "How Virtual Textures Really Work · shlom.dev",
    "Url": "https://www.shlom.dev/articles/how-virtual-textures-work/",
    "Timestamp": "2026-02-05T00:03:22",
    "Domain": "www.shlom.dev",
    "Description": "Virtual texturing is not about supporting larger textures, but about aligning memory residency with what can actually be visible on screen. This article explains the system end-to-end, from addressing to feedback and residency decisions."
  },
  {
    "Title": "The Toughest Sell: A Founder's Guide to Startup Exits",
    "Url": "https://derekyan.com/ma-book/",
    "Timestamp": "2026-02-05T00:03:18",
    "Domain": "derekyan.com",
    "Description": "A founder's account of selling a $13.5M-funded startup. 53 chapters covering four years, 100+ conversations, and hard lessons learned."
  },
  {
    "Title": "Inside NeurIPS 2025: Agents, World Models, and the Best Burritos in AI Research",
    "Url": "https://vindler.solutions/blog/neurips-2025-san-diego",
    "Timestamp": "2026-02-05T00:03:15",
    "Domain": "vindler.solutions",
    "Description": "Nearly 30,000 attendees, 21,000 paper submissions, and a community grappling with fundamental questions about where AI is headed. Our takeaways from the world's premier machine learning conference."
  },
  {
    "Title": "Claude Code Demystified: Whirring, Skidaddling, Flibbertigibetting",
    "Url": "https://www.mihaileric.com/Demystifying-Claude-Code/",
    "Timestamp": "2026-02-05T00:03:09",
    "Domain": "www.mihaileric.com",
    "Description": "There's a certain magic to watching Claude Code work. But what's actually happening when you issue a prompt to Claude?"
  },
  {
    "Title": "The Codex App Changes Everything!!! (not really)  | Ben Shoemaker",
    "Url": "https://www.benshoemaker.us/writing/codex-app-launch/",
    "Timestamp": "2026-02-05T00:03:02",
    "Domain": "www.benshoemaker.us",
    "Description": "The Codex desktop app doesn't change everything - but it's part of a larger trend worth paying attention to. Where IDEs are headed and why specs matter more than code."
  },
  {
    "Title": "Striking a Balance: Working Fully Remote for Nearly a Decade",
    "Url": "https://rion.io/2025/12/30/striking-a-balance-working-fully-remote-for-nearly-a-decade/",
    "Timestamp": "2026-02-05T00:02:59",
    "Domain": "rion.io",
    "Description": "Recently, I was chatting with an engineer who was transitioning into a fully remote role for the first time in their career. They were excited, but also had a touch of anxiety about it. For someone who had spent their entire career in the familiar commute → office → commute loop, this"
  },
  {
    "Title": "Why we built ModelRift on OpenSCAD | ModelRift Blog",
    "Url": "https://modelrift.com/blog/why-openscad/",
    "Timestamp": "2026-02-05T00:02:55",
    "Domain": "modelrift.com",
    "Description": "OpenSCAD's functional language makes it ideal for AI-assisted 3D modeling - better LLM generation, safer sandboxing, and fast rendering with Manifold."
  },
  {
    "Title": "When Claude Doesn't Understand Your Project: How I Built an Agent to Fix Context Issues",
    "Url": "https://johnoct.github.io/blog/2025/08/18/optimizing-claude-context-with-specialized-agent/",
    "Timestamp": "2026-02-05T00:02:49",
    "Domain": "johnoct.github.io",
    "Description": "August 18, 2025"
  },
  {
    "Title": "Client-Side Encrypted Posts in Jekyll",
    "Url": "https://www.joshbeckman.org/blog/encrypted-post",
    "Timestamp": "2026-02-05T00:02:45",
    "Domain": "www.joshbeckman.org",
    "Description": "I’ve been wanting to write more personal things on this site. Not everything needs to be public, but I still want the convenience of having it all in one place - searchable, linkable, backed up in git.\n\nSo I built client-side encryption into thi..."
  },
  {
    "Title": "Going Back to the Physical World",
    "Url": "https://josem.co/going-back-to-the-physical-world/",
    "Timestamp": "2026-02-05T00:02:41",
    "Domain": "josem.co",
    "Description": "Our world is quickly becoming a digital one. We now spend more time looking at pixels than at real things."
  }
]